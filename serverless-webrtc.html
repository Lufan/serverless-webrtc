<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebRTC p2p data</title>
    <script>
      // adapter.js
      var RTCPeerConnection = null
      var getUserMedia = null
      var webrtcDetectedBrowser = null

      if (navigator.mozGetUserMedia) {
        console.log('This appears to be Firefox')

        webrtcDetectedBrowser = 'firefox'

        // The RTCPeerConnection object.
        RTCPeerConnection = mozRTCPeerConnection

        // The RTCSessionDescription object.
        RTCSessionDescription = mozRTCSessionDescription

        // The RTCIceCandidate object.
        RTCIceCandidate = mozRTCIceCandidate

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.mozGetUserMedia.bind(navigator)


        // Fake get{Video,Audio}Tracks
        MediaStream.prototype.getVideoTracks = function () {
          return []
        }

        MediaStream.prototype.getAudioTracks = function () {
          return []
        }
      } else if (navigator.webkitGetUserMedia) {
        console.log('This appears to be Chrome')

        webrtcDetectedBrowser = 'chrome'

        // The RTCPeerConnection object.
        RTCPeerConnection = webkitRTCPeerConnection

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.webkitGetUserMedia.bind(navigator)

        // The representation of tracks in a stream is changed in M26.
        // Unify them for earlier Chrome versions in the coexisting period.
        if (!webkitMediaStream.prototype.getVideoTracks) {
          webkitMediaStream.prototype.getVideoTracks = function () {
            return this.videoTracks
          }
          webkitMediaStream.prototype.getAudioTracks = function () {
            return this.audioTracks
          }
        }

        // New syntax of getXXXStreams method in M26.
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
          webkitRTCPeerConnection.prototype.getLocalStreams = function () {
            return this.localStreams
          }
          webkitRTCPeerConnection.prototype.getRemoteStreams = function () {
            return this.remoteStreams
          }
        }
      } else {
        console.log('Browser does not appear to be WebRTC-capable')
      }

    </script>

    <script src="js/jquery-2.0.0.js"></script>
    <script src="js/bootstrap.js"></script>
    <link href="css/bootstrap.css" rel="stylesheet">
</head>
<body>

  <div class="text-info" id="chatlog" style="height:350px; overflow:auto;">
  </div>

  <form class="form-inline" onSubmit="return sendMessage()" action="">
    <input type="text" id="messageTextBox" placeholder="Type your message here">
    <button type="submit" id="sendMessageBtn" class="btn">Send message</button>
  </form>

<div>
  <div class="modal-body">
    Here's your "offer" -- it tells someone else how to connect to you.  Send the whole thing to them, for example in an instant message or e-mail.
  <br/>
  <textarea class="input-large" id="localOffer" name="localOffer" rows="10" cols="100"></textarea>
  </div>
  <div class="modal-footer">
    <button class="btn btn-primary" id="offerSentBtn" onclick="offerSentBtnClick()" data-dismiss="modal" aria-hidden="true">Okay, I sent it.</button>
  </div>
</div>

<div>
  <div class="modal-body">
    Here's your "answer" -- it tells someone else how to connect to you.  Send the whole thing to them, for example in an instant message or e-mail.
  <br/>
  <textarea class="input-large" id="localAnswer" name="localAnswer" rows="10" cols="100"></textarea>
  </div>
  <div class="modal-footer">
    <button class="btn btn-primary" id="answerSentBtn" onclick="answerSentBtnClick()" data-dismiss="modal" aria-hidden="true">Okay, I sent it.</button>
  </div>
</div>

<div>
  <div class="modal-body">
    The person who created the room will send you an "offer" string -- paste it here.
  <br/>
  <textarea class="input-large" id="remoteOffer" name="remoteOffer" rows="10" cols="100"></textarea>
  </div>
  <div class="modal-footer">
    <button class="btn btn-primary" id="offerRecdBtn" onclick="offerRecdBtnClick()" data-dismiss="modal" aria-hidden="true">Okay, I pasted it.</button>
  </div>
</div>

<div>
  <div class="modal-header">
    <h3 id="myModalLabel">Paste the "answer" you received</h3>
  </div>
  <div class="modal-body">
    Now paste in the "answer" that was sent back to you.
  <br/>
  <textarea class="input-large" id="remoteAnswer" name="remoteAnswer" rows="10" cols="100"></textarea>
  </div>
  <div class="modal-footer">
    <button class="btn btn-primary" id="answerRecdBtn" onclick="answerRecdBtnClick()" data-dismiss="modal" aria-hidden="true">Okay, I pasted it.</button>
  </div>
</div>

<div>
  <div class="modal-header">
    <h3 id="myModalLabel">Waiting for connection</h3>
  </div>
  <div class="modal-body">
    This dialog will disappear when a connection is made.
  </div>
  <div class="spinner" align="center">
    <img src="img/spinner.gif"></img>
  </div>
</div>

<div>
  <div class="modal-header">
    <h3 id="myModalLabel">Create or join a room?</h3>
  </div>
  <div class="modal-footer">
    <button class="btn" id="joinBtn" onclick="joinBtnClick()" data-dismiss="modal" aria-hidden="true">Join</button>
    <button class="btn btn-primary" id="createBtn" onclick="createBtnClick()" data-dismiss="modal" aria-hidden="true">Create</button>
  </div>
</div>

<script>
  //serverless-webrtc.js
/* See also:
    http://www.html5rocks.com/en/tutorials/webrtc/basics/
    https://code.google.com/p/webrtc-samples/source/browse/trunk/apprtc/index.html

    https://webrtc-demos.appspot.com/html/pc1.html
*/

var cfg = {'iceServers': [{'url': 'stun:23.21.150.121'}]},
  con = { 'optional': [{'DtlsSrtpKeyAgreement': true}] }

/* THIS IS ALICE, THE CALLER/SENDER */

var pc1 = new RTCPeerConnection(cfg, con),
  dc1 = null, tn1 = null

// Since the same JS file contains code for both sides of the connection,
// activedc tracks which of the two possible datachannel variables we're using.
var activedc

var pc1icedone = false

var sdpConstraints = {
  optional: [],
  mandatory: {
    OfferToReceiveAudio: true,
    OfferToReceiveVideo: true
  }
}

function createBtnClick() {
  createLocalOffer()
}

function joinBtnClick() {
  navigator.getUserMedia = navigator.getUserMedia ||
                           navigator.webkitGetUserMedia ||
                           navigator.mozGetUserMedia ||
                           navigator.msGetUserMedia;
}

function offerSentBtnClick() {
}

function offerRecdBtnClick() {
  var offer = document.getElementById('remoteOffer').value
  var offerDesc = new RTCSessionDescription(JSON.parse(offer))
  console.log('Received remote offer', offerDesc)
  writeToChatLog('Received remote offer', 'text-success')
  handleOfferFromPC1(offerDesc)
}

function answerSentBtnClick() {
}

function answerRecdBtnClick() {
  var answer = document.getElementById('remoteAnswer').value
  var answerDesc = new RTCSessionDescription(JSON.parse(answer))
  handleAnswerFromPC2(answerDesc)
}

function sendMessage () {
  if (document.getElementById('messageTextBox').value) {
    var channel = new RTCMultiSession()
    writeToChatLog(document.getElementById('messageTextBox').value, 'text-success')
    channel.send({message: document.getElementById('messageTextBox').value})
    document.getElementById('messageTextBox').value = '';

  }

  return false
}

function setupDC1 () {
  try {
    dc1 = pc1.createDataChannel('test', {reliable: true})
    activedc = dc1
    console.log('Created datachannel (pc1)')
    dc1.onopen = function (e) {
      console.log('data channel connect')
    }
    dc1.onmessage = function (e) {
      console.log('Got message (pc1)', e.data)
      if (e.data.charCodeAt(0) == 2) {
        // The first message we get from Firefox (but not Chrome)
        // is literal ASCII 2 and I don't understand why -- if we
        // leave it in, JSON.parse() will barf.
        return
      }
      console.log(e)
      var data = JSON.parse(e.data)
      writeToChatLog(data.message, 'text-info')
    }
  } catch (e) { console.warn('No data channel (pc1)', e); }
}

function createLocalOffer () {
  console.log('video1')
  navigator.getUserMedia = navigator.getUserMedia ||
                           navigator.webkitGetUserMedia ||
                           navigator.mozGetUserMedia ||
                           navigator.msGetUserMedia;
    setupDC1();
    pc1.createOffer(function (desc) {
        pc1.setLocalDescription(desc, function () {}, function () {})
        console.log('created local offer', desc)
      },
      function () { console.warn("Couldn't create offer") },
      sdpConstraints
    );
}

pc1.onicecandidate = function (e) {
  console.log('ICE candidate (pc1)', e)
  if (e.candidate == null) {
    document.getElementById('localOffer').innerText = JSON.stringify(pc1.localDescription);
  }
}

function handleOnconnection () {
  console.log('Datachannel connected')
  writeToChatLog('Datachannel connected', 'text-success')
}

pc1.onconnection = handleOnconnection

function onsignalingstatechange (state) {
  console.info('signaling state change:', state)
}

function oniceconnectionstatechange (state) {
  console.info('ice connection state change:', state)
}

function onicegatheringstatechange (state) {
  console.info('ice gathering state change:', state)
}

pc1.onsignalingstatechange = onsignalingstatechange
pc1.oniceconnectionstatechange = oniceconnectionstatechange
pc1.onicegatheringstatechange = onicegatheringstatechange

function handleAnswerFromPC2 (answerDesc) {
  console.log('Received remote answer: ', answerDesc)
  writeToChatLog('Received remote answer', 'text-success')
  pc1.setRemoteDescription(answerDesc)
}

function handleCandidateFromPC2 (iceCandidate) {
  pc1.addIceCandidate(iceCandidate)
}

/* THIS IS BOB, THE ANSWERER/RECEIVER */

var pc2 = new RTCPeerConnection(cfg, con),
  dc2 = null

var pc2icedone = false

pc2.ondatachannel = function (e) {
  var datachannel = e.channel || e; // Chrome sends event, FF sends raw channel
  console.log('Received datachannel (pc2)', arguments)
  dc2 = datachannel
  activedc = dc2
  dc2.onopen = function (e) {
    console.log('data channel connect')
  }
  dc2.onmessage = function (e) {
    console.log('Got message (pc2)', e.data)
    var data = JSON.parse(e.data)
    writeToChatLog(data.message, 'text-info')
  }
}

function handleOfferFromPC1 (offerDesc) {
  pc2.setRemoteDescription(offerDesc)
  pc2.createAnswer(function (answerDesc) {
    writeToChatLog('Created local answer', 'text-success')
    console.log('Created local answer: ', answerDesc)
    pc2.setLocalDescription(answerDesc)
  },
  function () { console.warn("Couldn't create offer") },
  sdpConstraints)
}

pc2.onicecandidate = function (e) {
  console.log('ICE candidate (pc2)', e)
  if (e.candidate == null) {
    document.getElementById('localAnswer').innerText = JSON.stringify(pc2.localDescription);
  }
}

pc2.onsignalingstatechange = onsignalingstatechange
pc2.oniceconnectionstatechange = oniceconnectionstatechange
pc2.onicegatheringstatechange = onicegatheringstatechange

function handleCandidateFromPC1 (iceCandidate) {
  pc2.addIceCandidate(iceCandidate)
}

pc2.onconnection = handleOnconnection

function getTimestamp () {
  var totalSec = new Date().getTime() / 1000
  var hours = parseInt(totalSec / 3600) % 24
  var minutes = parseInt(totalSec / 60) % 60
  var seconds = parseInt(totalSec % 60)

  var result = (hours < 10 ? '0' + hours : hours) + ':' +
    (minutes < 10 ? '0' + minutes : minutes) + ':' +
    (seconds < 10 ? '0' + seconds : seconds)

  return result
}

function writeToChatLog (message, message_type) {
  document.getElementById('chatlog').innerHTML += '<p class="' + message_type + '">' + '[' + getTimestamp() + '] ' + message + '</p>'
}
</script>
<script>
  // js/file-transfer.js
/*  MIT License: https://webrtc-experiment.appspot.com/licence/
 *	2013, Muaz Khan<muazkh>--[ github.com/muaz-khan ]
 */
/* For documentation and examples: http://bit.ly/RTCDataConnection */

window.moz = !! navigator.mozGetUserMedia

var RTCMultiSession = function (options) {
  return {
    send: function (message) {
      if (moz && message.file)
        data = message.file
      else
        data = JSON.stringify(message)

      activedc.send(data)
    }
  }
}

</script>
</body>
</html>
